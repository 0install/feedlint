#!/usr/bin/env python

from optparse import OptionParser
import sys, shutil, tempfile, urlparse
import socket
import urllib2, os, httplib
import ftplib
import logging, time, traceback
from logging import info

from zeroinstall import SafeException
from zeroinstall.injector import model, gpg, namespaces, qdom

from display import checking, result, error, highlight, error_new_line

now = time.time()

version = '0.7'

WEEK = 60 * 60 * 24 * 7

def host(address):
	if hasattr(address, 'hostname'):
		return address.hostname
	else:
		return address[1].split(':', 1)[0]

def port(address):
	if hasattr(address, 'port'):
		return address.port
	else:
		port = address[1].split(':', 1)[1:]
		if port:
			return int(port[0])
		else:
			return None

assert port(('http', 'foo:81')) == 81
assert port(urlparse.urlparse('http://foo:81')) == 81

parser = OptionParser(usage="usage: %prog [options] feed.xml")
parser.add_option("-d", "--dependencies", help="also check feeds for dependencies", action='store_true')
parser.add_option("-s", "--skip-archives", help="don't check the archives are OK", action='store_true')
parser.add_option("-v", "--verbose", help="more verbose output", action='count')
parser.add_option("-V", "--version", help="display version information", action='store_true')

(options, args) = parser.parse_args()

if options.version:
	print "FeedLint (zero-install) " + version
	print "Copyright (C) 2007 Thomas Leonard"
	print "This program comes with ABSOLUTELY NO WARRANTY,"
	print "to the extent permitted by law."
	print "You may redistribute copies of this program"
	print "under the terms of the GNU General Public License."
	print "For more information about these matters, see the file named COPYING."
	sys.exit(0)

if options.verbose:
	logger = logging.getLogger()
	if options.verbose == 1:
		logger.setLevel(logging.INFO)
	else:
		logger.setLevel(logging.DEBUG)

if len(args) < 1:
	parser.print_help()
	sys.exit(1)

checked = set()

try:
	to_check = [model.canonical_iface_uri(a) for a in args]
except SafeException, ex:
	if options.verbose: raise
	print >>sys.stderr, ex
	sys.exit(1)

def check_key(feed, fingerprint):
	for line in os.popen('gpg --with-colons --list-keys %s' % s.fingerprint):
		if line.startswith('pub:'):
			key_id = line.split(':')[4]
			break
	else:
		raise SafeException('Failed to find key with fingerprint %s on your keyring' % fingerprint)

	key_url = urlparse.urljoin(feed, '%s.gpg' % key_id)

	if key_url in checked:
		info("(already checked key URL %s)", key_url)
	else:
		checking("Checking key %s" % key_url)
		urllib2.urlopen(key_url).read()
		result('OK')
		checked.add(key_url)

def get_http_size(url, ttl = 3):
	address = urlparse.urlparse(url)

	if url.lower().startswith('http://'):
		http = httplib.HTTPConnection(host(address), port(address) or 80)
	elif url.lower().startswith('https://'):
		http = httplib.HTTPSConnection(host(address), port(address) or 443)
	else:
		assert False, url

	parts = url.split('/', 3)
	if len(parts) == 4:
		path = parts[3]
	else:
		path = ''

	http.request('HEAD', '/' + path, headers = {'Host': host(address)})
	response = http.getresponse()
	try:
		if response.status == 200:
			return response.getheader('Content-Length')
		elif response.status in (301, 302, 303):
			new_url_rel = response.getheader('Location') or response.getheader('URI')
			new_url = urlparse.urljoin(url, new_url_rel)
		else:
			raise SafeException("HTTP error: got status code %s" % response.status)
	finally:
		response.close()

	if ttl:
		result("Moved", 'YELLOW')
		checking("Checking new URL %s" % new_url)
		assert new_url
		return get_http_size(new_url, ttl - 1)
	else:
		raise SafeException('Too many redirections.')

def get_ftp_size(url):
	address = urlparse.urlparse(url)
	ftp = ftplib.FTP(host(address))
	try:
		ftp.login()
		ftp.voidcmd('TYPE I')
		return ftp.size(url.split('/', 3)[3])
	finally:
		ftp.close()

def get_size(url):
	scheme = urlparse.urlparse(url)[0].lower()
	if scheme.startswith('http') or scheme.startswith('https'):
		return get_http_size(url)
	elif scheme.startswith('ftp'):
		return get_ftp_size(url)
	else:
		raise SafeException("Unknown scheme '%s' in '%s'" % (scheme, url))

def check_source(source):
	if hasattr(source, 'url'):
		checking("Checking archive %s" % source.url)
		actual_size = get_size(source.url)
		if actual_size is None:
			result("No Content-Length for archive; can't check", 'YELLOW')
		else:
			actual_size = int(actual_size)
			expected_size = source.size + (source.start_offset or 0)
			if actual_size != expected_size:
				error('Bad length')
				raise SafeException("Expected archive to have a size of %d, but server says it is %d" %
						(expected_size, actual_size))
			result('OK')
	elif hasattr(source, 'steps'):
		for step in source.steps:
			check_source(step)

existing_urls = set()
def check_exists(url):
	if url in existing_urls: return		# Already checked

	checking("Checking URL exists %s" % url)
	get_size(url)
	result('OK')
	existing_urls.add(url)

n_errors = 0

while to_check:
	feed = to_check.pop()
	if feed in checked:
		info("Already checked feed %s", feed)
		continue

	checked.add(feed)

	checking("Checking " + feed, indent = 0)

	try:
		if feed.startswith('/'):
			with open(feed) as stream:
				feed_obj = model.ZeroInstallFeed(qdom.parse(stream), local_path = feed)
			result('Local')
		else:
			tmp = tempfile.TemporaryFile(prefix = 'feedlint-')
			try:
				try:
					stream = urllib2.urlopen(feed)
					shutil.copyfileobj(stream, tmp)
				except Exception as ex:
					raise SafeException('Failed to fetch feed: {ex}'.format(ex = ex))
				tmp.seek(0)
				start = tmp.read(5)
				if start == '<?xml':
					result('Fetched')
				elif start == '-----':
					result('Old sig', colour = 'YELLOW')
					error_new_line('  Feed has an old-style plain GPG signature. Use 0publish --xmlsign.',
							colour = 'YELLOW')
				else:
					result('Fetched')
					error_new_line('  Unknown format. File starts "%s"' % start)

				tmp.seek(0)
				data, sigs = gpg.check_stream(tmp)

				for s in sigs:
					if isinstance(s, gpg.ValidSig):
						check_key(feed, s.fingerprint)
					else:
						raise SafeException("Can't check sig: %s" % s)

				feed_obj = model.ZeroInstallFeed(qdom.parse(data))

				if feed_obj.url != feed:
					raise SafeException('Incorrect URL "%s"' % feed_obj.url)

			finally:
				tmp.close()

		for f in feed_obj.feeds:
			info("Will check feed %s", f.uri)
			to_check.append(f.uri)

		highest_version = None
		for impl in feed_obj.implementations.values():
			if hasattr(impl, 'dependencies'):
				for r in impl.dependencies.values():
					if r.interface not in checked:
						info("Will check dependency %s", r)
						if options.dependencies:
							to_check.append(r.interface)
						else:
							check_exists(r.interface)
			if hasattr(impl, 'download_sources') and not options.skip_archives:
				for source in impl.download_sources:
					check_source(source)
			stability = impl.upstream_stability or model.testing
			if highest_version is None or impl.version > highest_version.version:
				highest_version = impl
			if stability == model.testing:
				testing_error = None
				if not impl.released:
					testing_error = "No release data on testing version"
				else:
					try:
						released = time.strptime(impl.released, '%Y-%m-%d')
					except ValueError, ex:
						testing_error = "Can't parse date"
					else:
						ago = now - time.mktime(released)
						if ago < 0:
							testing_error = 'Release data is in the future!'
				if testing_error:
					raise SafeException("Version %s: %s (released %s)" % (impl.get_version(), testing_error, impl.released))

		if highest_version and (highest_version.upstream_stability or model.testing) is model.testing:
			print highlight('  Highest version (%s) is still "testing"' % highest_version.get_version(), 'YELLOW')
		
		for homepage in feed_obj.get_metadata(namespaces.XMLNS_IFACE, 'homepage'):
			check_exists(homepage.content)

		for icon in feed_obj.get_metadata(namespaces.XMLNS_IFACE, 'icon'):
			check_exists(icon.getAttribute('href'))
				
	except (urllib2.HTTPError, httplib.BadStatusLine, socket.error, ftplib.error_perm), ex:
		err_msg = str(ex).strip() or str(type(ex))
		error_new_line('  ' + err_msg)
		n_errors += 1
		if options.verbose: traceback.print_exc()
	except SafeException, ex:
		if options.verbose: raise
		error_new_line('  ' + str(ex))
		n_errors += 1

if n_errors == 0:
	print "OK"
else:
	print "\nERRORS FOUND:", n_errors
	sys.exit(1)
